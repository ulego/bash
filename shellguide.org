* Shell руководство по стилю
  :PROPERTIES:
  :CUSTOM_ID: shell-style-guide
  :END:

#+begin_html
  <!-- Номер ревизии сохраняется вручную.
       Основные числа:
         1 = shell.xml
         2 = shell.md
       Основное число также жестко закодировано в нижней части этого файла. -->
#+end_html

Редакция 2.02
Создано, переработано и поддерживается многими сотрудниками Google.

** Содержание
   :PROPERTIES:
   :CUSTOM_ID: table-of-contents
   :END:
| Секция                                 | Содержание                                                                                                                                                                                    |
|----------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [[#s1-background][Фон]]                                    | [[#s1.1-which-shell-to-use][Какую оболочку использовать]] - [[#s1.2-when-to-use-shell][Когда использовать оболочку]]                                                                                                                                     |
| [[#s2-shell-files-and-interpreter-invocation][Вызов файлов оболочки и интерпретатора]] | [[#s2.1-file-extensions][Расширения файлов]] - [[#s2.2-suid-sgid][SUID/SGID]]                                                                                                                                                                 |
| [[#s3-environment][Окружение]]                              | [[#s3.1-stdout-vs-stderr][STDOUT против STDERR]]                                                                                                                                                                          |
| [[#s4-comments][Комментарии]]                            | [[#s4.1-file-header][Заголовок файла]] - [[#s4.2-function-comments][Комментарии к функциям]] - [[#s4.3-implementation-comments][Комментарии к реализации]] - [[#s4.4-todo-comments][Комментарии TODO]]                                                                                                        |
| [[#s5-formatting][Форматирование]]                         | [[#s5.1-indentation][Отступ]] - [[#s5.2-line-length-and-long-strings][Длина строки и длинные строки]] - [[#s5.3-pipelines][Конвейеры]] - [[#s5.4-loops][Циклы]] - [[#s5.5-case-statement][Оператор Case]] - [[#s5.6-variable-expansion][Раскрытие переменной]] - [[#s5.7-quoting][Кавычки]]                                                                                     |
| [[#s6-features-and-bugs][Функции и ошибки]]                       | [[#s6.1-shellcheck][ShellCheck]] - [[#s6.2-command-substitution][Подстановка команд]] - [[#s6.3-tests][Тест, =[ ... ]= и =[[... ]]= ]] - [[#s6.4-testing-strings][Тестирование строк]] - [[#s6.5-wildcard-expansion-of-filenames][Подстановочные знаки расширения имен файлов]] - [[#s6.6-eval][Eval]] - [[#s6.7-arrays][Массивы]] - [[#s6.8-pipes-to-while][Перенаправление в цикл while]] - [[#s6.9-arithmetic][Арифметика]]                          |
| [[#s7-naming-conventions][Соглашения об именах]]                   | [[#s7.1-function-names][Имена функций]] - [[#s7.2-name-variables][Имена переменных]] - [[#s7.3-constants-and-environment-variable-names][Имена констант и переменных среды]] - [[#s7.4-source-filenames][Имена исходных файлов]] - [[#s7.5-read-only-variables][Переменные только для чтения]] - [[#s7.6-use-local-variables][Использовать локальные переменные]] - [[#s7.7-function-location][Расположение функции]] - [[#s7.8-main][функция main]] |
| [[#s8-calling-commands][вызов команд]]                           | [[#s8.1-checking-return-values][Проверка возвращаемых значений]] - [[#s8.2-builtin-commands-vs-external-commands][Встроенные команды и внешние команды]]                                                                                                                         |
| [[#s9-conclusion][Заключение]]                             |                                                                                                                                                                                               |
|                                        |                                                                                                                                                                                               |

** Фон
   :PROPERTIES:
   :CUSTOM_ID: s1-background
   :END:

*** Какую оболочку использовать
    :PROPERTIES:
    :CUSTOM_ID: s1.1-which-shell-to-use
    :END:
Bash — единственный язык сценариев оболочки, разрешенный для исполняемых файлов.
Исполняемые файлы должны начинаться с =#!/bin/bash= и иметь минимальное количество флагов.
Используйте =set=, для того чтобы задать параметры оболочки, и  вызвать сценарий как =bash script_name= не нарушая его функциональность.
Ограничение всех исполняемых сценариев оболочки /bash/ дает нам консистентность языка оболочки, который установлен на всех наших машинах.
Единственным исключением из этого правила являются вынужденные условия. Одним из примеров этого являются пакеты Solaris SVR4, которые требуют: простая оболочка Bourne для любых скриптов.

*** Когда следует использовать оболочку
    :PROPERTIES:
    :CUSTOM_ID: s1.2-when-to-use-shell
    :END:
Оболочку следует использовать только для небольших утилит или простых скриптов-оболочек.
Хотя сценарии оболочки не являются языком разработки, они используются для написания различных служебных скриптов в Google. Это руководство по стилю скорее рекомендация по его использованию, а не предложение о его широком внедрении.

Некоторые рекомендации:
- Если вы в основном вызываете другие утилиты и делаете относительном мало манипуляций с данными, оболочка является приемлемым выбором для задачи.
- Если производительность имеет значение, используйте что-то другое, кроме оболочки.
- Если вы пишете сценарий длиной более 100 строк или что-то, что использует непонятную логику потока управления, вы должны переписать его в более структурированный язык /сейчас/. Имейте в виду, что скрипты растут. Перепишите сценарий заранее, чтобы избежать более трудоемкого переписывания на более позднем этапе.
- При оценке сложности вашего кода (например, чтобы решить, следует ли переключиться в другой язык) подумайте, легко ли поддерживать код другим людям.

** Вызов файлов оболочки и интерпретатора
   :PROPERTIES:
   :CUSTOM_ID: s2-shell-files-and-interpreter-invocation
   :END:

*** Расширения файлов
    :PROPERTIES:
    :CUSTOM_ID: s2.1-file-extensions
    :END:
Исполняемые файлы не должны иметь расширения (настоятельно рекомендуется) или иметь =.sh= расширение. Библиотеки должны иметь расширение =.sh= и не должны быть исполняемыми.
Не обязательно знать, на каком языке написана программа, когда она выполняется и оболочка не требуют расширения, поэтому мы предпочитаем его не использовать.
Однако для библиотек важно знать, какой это язык и иногда возникает необходимость иметь похожие библиотеки в разных языках. Это позволяет использовать библиотечные файлы с идентичными целями, но для разных языковпоэтому они могут быть одинаково названы, за исключением языкового суффикса.

*** SUID/SGID
    :PROPERTIES:
    :CUSTOM_ID: s2.2-suid-sgid
    :END:
SUID и SGID /запрещены/ в сценариях оболочки.
В оболочке слишком много проблем с безопасностью, которые делают почти невозможным разрешение SUID/SGID. В то время как bash затрудняет запуск SUID, на некоторых платформах это все еще возможно - вот почему мы прямо заявляем о его запрете.
Используйте =sudo=, чтобы обеспечить повышенный доступ, если он вам нужен.

** Окружение
   :PROPERTIES:
   :CUSTOM_ID: s3-environment
   :END:

*** STDOUT против STDERR
    :PROPERTIES:
    :CUSTOM_ID: s3.1-stdout-vs-stderr
    :END:
Все сообщения об ошибках должны быть отправлены в =STDERR=.
Это облегчает отделение нормального состояния от фактических проблем.
Рекомендуется исползование функции печати сообщений об ошибках вместе с другими статусами информации.

#+begin_example
err() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*" >&2
}

if ! do_something; then
  err "Unable to do_something"
  exit 1
fi
#+end_example

** Комментарии
   :PROPERTIES:
   :CUSTOM_ID: s4-comments
   :END:

*** Заголовок файла
    :PROPERTIES:
    :CUSTOM_ID: s4.1-file-header
    :END:
Начинайте каждый файл с описания его содержимого.
Каждый файл должен иметь комментарий верхнего уровня, включающий краткий обзор его содержания. Уведомление об авторских правах и информация об авторе не являются обязательными.

Пример:
#+begin_example
#!/bin/bash
#
# Выполнение резервного копирования баз данных Oracle.
#+end_example

*** Комментарии к функциям
    :PROPERTIES:
    :CUSTOM_ID: s4.2-function-comments
    :END:
Любая функция, которая не является одновременно очевидной и короткой, должна быть прокомментирована. Любая функция в библиотеке должна быть прокомментирована независимо от длины или сложности.
У кого-то еще должна быть возможность узнать, как использовать вашу программу или использовать функцию в вашей библиотеке, прочитав комментарии (и помощь, если предусмотрено) без считывания кода.

Все комментарии к функциям должны описывать предполагаемое поведение API с использованием:
- Описание функции.
- Globals: Список используемых и измененных глобальных переменных.
- Аргументы: Аргументы для передачи.
- Вывод: Вывод на STDOUT или STDERR.
- Возвращает: возвращаемые значения, отличные от состояния выхода по умолчанию последней команды.

Пример:
#+begin_example
#######################################
# Очистите файлы из каталога резервных копий.
# Globals:
#   BACKUP_DIR
#   ORACLE_SID
# Arguments:
#   None
#######################################
function cleanup() {
  …
}

#######################################
# Получите каталог конфигурации.
# Globals:
#   SOMEDIR
# Arguments:
#   None
# Outputs:
#   Writes location to stdout
#######################################
function get_dir() {
  echo "${SOMEDIR}"
}

#######################################
# Удалите файл сложным способом.
# Arguments:
#   File to delete, a path.
# Returns:
#   0 if thing was deleted, non-zero on error.
#######################################
function del_thing() {
  rm "$1"
}
#+end_example

*** Комментарии по реализации
    :PROPERTIES:
    :CUSTOM_ID: s4.3-implementation-comments
    :END:
Комментируйте сложные, неочевидные, интересные или важные части вашего кода.
Это соответствует общей практике комментариев к кодированию Google. Не комментируйте всё. Если есть сложный алгоритм или вы что-то делаете из обычных, поставьте короткий комментарий.

*** Комментарии TODO
    :PROPERTIES:
    :CUSTOM_ID: s4.4-todo-comments
    :END:
Используйте комментарии TODO для кода, который является временным, краткосрочным решением или он достаточно хорош, но не идеален.
Это соответствует соглашению в
[[https://google.github.io/styleguide/cppguide.html#TODO_Comments][C++ Guide]].

=TODO=s должен включать строку =TODO= заглавными буквами, за которой следует имя, адрес электронной почты или другой идентификатор лица с исчерпывающим  контекстом о проблеме, на которую ссылается =TODO=. Основная цель - иметь согласованный =TODO=, который можно искать, чтобы узнать, как получить более подробную информацию по запросу. A =TODO= не является обязательством, по которому человек сможет решить проблему, таким образом, когда вы создаете =TODO= - это почти всегда для вас самих.

Примеры:
#+begin_example
# TODO(mrmonkey): Обработка маловероятных крайних случаев (bug ####)
#+end_example

** Форматирование
   :PROPERTIES:
   :CUSTOM_ID: s5-formatting
   :END:
В то время как вы должны следовать стилю, который уже существует для файлов, которые вы изменяете, для любого нового кода требуется следующее.

*** Отступ
    :PROPERTIES:
    :CUSTOM_ID: s5.1-indentation
    :END:
Отступ 2 пробела. Никаких ТАБов.
Используйте пустые строки между блоками, чтобы улучшить читаемость. Отступ равен два пробела. Что бы вы ни делали, не используйте табы. Для существующих файлов оставайтесь верными существующему отступу.

*** Длина строки и длинные строки
    :PROPERTIES:
    :CUSTOM_ID: s5.2-line-length-and-long-strings
    :END:
Максимальная длина строки составляет 80 символов.

Если вам нужно написать строки длиннее 80 символов, это должно быть сделано с помощью HEREDOC (EOF, END), или встроенной новой строки, если это возможно.
Литеральные строки, которые должны быть длиннее 80 символов и не могут разумно быть разделенным - это нормально, но настоятельно предпочтительнее найти способ сделать их короче.

#+begin_example
# Используйте 'here document's
cat <<END
I am an exceptionally long
string.
END

# Embedded newlines are ok too
long_string="I am an exceptionally
long string."
#+end_example

*** Pipelines
    :PROPERTIES:
    :CUSTOM_ID: s5.3-pipelines
    :END:
Конвейеры должны быть разделены по одному на линию, если они не все помещаются на одной линии.

Если весь pipe  помещается на одной линии, он должен быть на одной линии. Если нет, он должен быть разделен на один сегмент на линию с включенной новой строкой и отступом в 2 пробела для следующего участка. Это применяется к цепочке команд, объединенных с помощью =|=, а также к логическим связкам, использующим =||= и =&&=.

#+begin_example
# Все укладывается в одну линию
command1 | command2

# Длинные команды
command1 \
  | command2 \
  | command3 \
  | command4
#+end_example

*** Циклы
    :PROPERTIES:
    :CUSTOM_ID: s5.4-loops
    :END:
Поместите  =; do= и =; then= в той же строке, что и =while=, =for= или =if=.

Циклы в shell немного отличаются, но мы следуем тем же принципам, что и с фигурными скобками при объявлении функций. То есть: =; затем= и =; do= должно находиться в той же строке, что и if/for/while. =else= должно быть на его собственной строке и заключительные операторы должны располагаться на отдельной строке по вертикали согласованным с началом условия.

Пример:
#+begin_example
# Внутри функции рассмотрите возможность объявления переменной цикла как
# локальной, чтобы избежать его утечки в глобальную среду:
# local dir
for dir in "${dirs_to_cleanup[@]}"; do
  if [[ -d "${dir}/${ORACLE_SID}" ]]; then
    log_date "Cleaning up old files in ${dir}/${ORACLE_SID}"
    rm "${dir}/${ORACLE_SID}/"*
    if (( $? != 0 )); then
      error_message
    fi
  else
    mkdir -p "${dir}/${ORACLE_SID}"
    if (( $? != 0 )); then
      error_message
    fi
  fi
done
#+end_example

*** Оператор ветвления case
    :PROPERTIES:
    :CUSTOM_ID: s5.5-case-statement
    :END:
- Отступ альтернатив на 2 пробела.
- Альтернатива с одной строкой требует пробела после закрывающей скобки паттерна и перед =;; =.
- Длинные или многокомандные альтернативы должны быть разделены на несколько строк  с паттерном, действиями и =;; = в отдельных строках.

Совпадающие выражения имеют отступ в один уровень от =case= и =esac=. Многострочные действия имеют отступ еще одного уровня. В общем, там нет необходимости заключать в кавычки выражения соответствия. Выражениям шаблона не должны предшествовать открытая круглая скобка. Избегайте =;&= и =;; &=.

#+begin_example
case "${expression}" in
  a)
    variable="…"
    some_command "${variable}" "${other_expr}" …
    ;;
  absolute)
    actions="relative"
    another_command "${actions}" "${other_expr}" …
    ;;
  *)
    error "Unexpected expression '${expression}'"
    ;;
esac
#+end_example

Простые команды могут быть помещены в ту же строку, что и шаблон =;; = до тех пор, пока выражение остается читабельным. Это часто уместно для обработки однобуквенных опций. Когда действия не укладываются на одну линию, поместите их на свои линии, затем действия, затем =;; = на собственных линиях. Если вы находитесь в той же строке, что и действия, используйте пробел после закрытой скобки шаблона и еще один перед =;; =.

#+begin_example
verbose='false'
aflag=''
bflag=''
files=''
while getopts 'abf:v' flag; do
  case "${flag}" in
    a) aflag='true' ;;
    b) bflag='true' ;;
    f) files="${OPTARG}" ;;
    v) verbose='true' ;;
    *) error "Unexpected option ${flag}" ;;
  esac
done
#+end_example

*** Раскрытие переменных 
    :PROPERTIES:
    :CUSTOM_ID: s5.6-variable-expansion
    :END:
В порядке важности: Оставайтесь последовательными в том, что вы нашли; Процитируйте свои переменные; предпочитайте ="${var}"= перед ="$var"=.

Это настоятельно рекомендуемые руководящие принципы, но не обязательные.
Тем не менее, тот факт, что это рекомендация, а не обязательное правило не значит, что к этому следует относиться легкомысленно или преуменьшать.

Они перечислены в порядке важности.
- Оставайтесь в соответствии с тем, что вы находите для существующего кода.
- Переменные котировок, см. [[#s5.7-quoting][Раздел цитирования ниже]].
- Не разграничьте одиночные символьные оболочки специальные / позиционные
  параметры, за исключением случаев, когда это строго необходимо или во избежание глубокой путаницы.
  Отдавайте предпочтение всем остальным переменным, разграничивающим фигурные скобки.

  #+begin_example
  # Раздел *рекомендуемых* случаев.

  # Предпочтительный стиль для 'специальных' переменных:
  echo "Positional: $1" "$5" "$3"
  echo "Specials: !=$!, -=$-, _=$_. ?=$?, #=$# *=$* @=$@ \$=$$ …"

  # Брекеты необходимы:
  echo "many parameters: ${10}"

  # Брекеты, чтобы избежать путаницы:
  # На выходе "a0b0c0"
  set -- a b c
  echo "${1}0${2}0${3}0"

  # Предпочтительный стиль для других переменных:
  echo "PATH=${PATH}, PWD=${PWD}, mine=${some_var}"
  while read -r f; do
    echo "file=${f}"
  done < <(find /tmp)
  #+end_example

  #+begin_example
  # Раздел *обескураживающих* дел

  # Вары без кавычек, вары без скобок, одиночные буквы с разделителями скобок
  # shell specials.
  echo a=$avar "b=$bvar" "PID=${$}" "${1}"

  # Confusing use: this is expanded as "${1}0${2}0${3}0",
  # not "${10}${20}${30}
  set -- a b c
  echo "$10$20$30"
  #+end_example

ПРИМЕЧАНИЕ: Использование фигурных скобок в =${var}= является /not/ формой кавычек. «Двойной
кавычки" должны быть использованы /также/.
*** Цитирование
    :PROPERTIES:
    :CUSTOM_ID: s5.7-quoting
    :END:
- Всегда заключайте в кавычки строки, содержащие переменные, подстановки команд,
  пробелы или метасимволы оболочки, если только осторожное расширение без кавычек не является
  требуется или это целое число оболочки (см. следующий пункт).
- Используйте массивы для безопасного цитирования списков элементов, особенно
  флаги командной строки. Смотрите [[#arrays][Arrays]] ниже.
- При необходимости заключайте в кавычки внутренние переменные, доступные только для чтения, которые
  определены как целые числа: =$?=, =$#=, =$$=, =$!= (man bash). Предпочитать
  цитирование "именованных" внутренних целочисленных переменных, например, PPID и т.д.
  последовательность.
- Предпочитайте кавычки строк, которые являются «словами» (в отличие от параметров команд).
  или имена путей).
- Никогда не заключайте в кавычки /literal/ целые числа.
- Помните о правилах цитирования совпадений шаблонов в =[[ ... ]] =. Видеть
  [[#s6.3-tests][Тест, =[ ... ] = и =[ ... ]] =]] ниже.
- Используйте ="$@"=, если у вас нет конкретной причины использовать =$*=, например
  просто добавление аргументов к строке в сообщении или журнале.

#+begin_example
# «Одинарные» кавычки указывают на то, что замена нежелательна.
# «Двойные» кавычки указывают на то, что подстановка необходима/допустима.

# Простые примеры

# "Подстановка команд кавычек"
# Обратите внимание, что кавычки, вложенные в "$()", не нуждаются в экранировании.
flag="$(some_command and its args "$@" 'quoted separately')"

# "переменные котировок"
echo "${flag}"

# Используйте массивы с расширением в кавычках для списков.
declare -a FLAGS
FLAGS=( --foo --bar='baz' )
readonly FLAGS
mybinary "${FLAGS[@]}"

# Нельзя заключать внутренние целочисленные переменные в кавычки.
if (( $# > 3 )); then
  echo "ppid=${PPID}"
fi

# "Никогда не заключайте в кавычки литеральные целые числа"
value=32
# "подстановка команд в кавычки", даже если вы ожидаете целых чисел
number="$(generate_number)"

# «предпочитать слова в кавычках», не обязательно
readonly USE_INTEGER='true'

# "Мета-символы кавычек оболочки"
echo 'Hello stranger, and well met. Earn lots of $$$'
echo "Process $$: Done making \$\$\$."

# "Параметры команд или имена путей"
# ($1 предполагается, что здесь есть значение)
grep -li Hugo /dev/null "$1"

# Менее простые примеры
# "quote variables, если не доказано ложь": ccs может быть пустым
git send-email --to "${reviewers}" ${ccs:+"--cc" "${ccs}"}

# Меры предосторожности при позиционных параметрах: 1 доллар может быть не установлен
# Одинарные кавычки оставляют регулярное выражение как есть.
grep -cP '([Ss]pecial|\|?characters*)$' ${1:+"$1"}

# Для передачи аргументов,
# "$@" почти каждый раз прав, и
# $* ошибается почти каждый раз:
#
# * $* и $@ будут разбиваться на пробелы, забивая аргументы
#, содержащие пробелы и пропускающие пустые строки;
# * "$@" сохранит аргументы как есть, поэтому без args
# при условии не приведет к тому, что args не будет передан;
# В большинстве случаев это то, что вы хотите использовать для прохождения
# на аргументах.
# * "$*" расширяется до одного аргумента со всеми объединенными args
# (обычно) пробелами,
# Таким образом, отсутствие предоставленных args приведет к одной пустой строке
# передается.
# (Обратитесь к 'man bash' для придирок ;-)

(set -- 1 "2 two" "3 three tres"; echo $#; set -- "$*"; echo "$#, $@")
(set -- 1 "2 two" "3 three tres"; echo $#; set -- "$@"; echo "$#, $@")
#+end_example

** Особенности и ошибки
   :PROPERTIES:
   :CUSTOM_ID: s6-features-and-bugs
   :END:

*** ShellCheck
    :PROPERTIES:
    :CUSTOM_ID: s6.1-shellcheck
    :END:
Проект [[https://www.shellcheck.net/][ShellCheck]] определяет
Распространенные ошибки и предупреждения для сценариев оболочки. Рекомендуется для:
Все скрипты, большие или маленькие.

*** Подстановка команд
    :PROPERTIES:
    :CUSTOM_ID: s6.2-command-substitution
    :END:
Используйте =$(команда)= вместо обратных галочек.

Вложенные обратные тики требуют экранирования внутренних с помощью =\=. Тем
=$(команда)= формат не меняется при вложении и легче читается.

Пример:
#+begin_example
# Это предпочтительно:
var="$(command "$(command1)")"
#+end_example

#+begin_example
# Это не:
var="`command \`command1\``"
#+end_example

*** Тест, =[ ... ] = и =[ ... ]] =
    :PROPERTIES:
    :CUSTOM_ID: s6.3-tests
    :END:

=[[ ... ]]= предпочтительнее, чем =[ ... ]=, =test= и =/usr/bin/[=.

=[[ ... ]]= Уменьшает количество ошибок, так как нет расширения пути или разделения слов
происходит между =[[= и =]]=. Кроме того, =[[ ... ]]= позволяет
сопоставление регулярных выражений, в то время как =[ ... ]= не имеет.

#+begin_example
# Это гарантирует, что строка слева состоит из символов в
# Класс символов ALNUM, за которым следует имя строки.
# Обратите внимание, что RHS не следует цитировать здесь.
if [[ "filename" =~ ^[[:alnum:]]+name ]]; then
  echo "Match"
fi

# Это соответствует точному шаблону "f*" (в данном случае не совпадает)
if [[ "filename" == "f*" ]]; then
  echo "Match"
fi
#+end_example

#+begin_example
# Это дает ошибку «слишком много аргументов», так как f* расширяется до
# Содержимое текущего каталога
if [ "filename" == f* ]; then
  echo "Match"
fi
#+end_example

Подробности см. в E14 по адресу
http://tiswww.case.edu/php/chet/bash/FAQ

*** Тестирование строк
    :PROPERTIES:
    :CUSTOM_ID: s6.4-testing-strings
    :END:
По возможности используйте кавычки, а не символы-заполнители.

Bash достаточно умен, чтобы справиться с пустой строкой в тесте. Итак, учитывая
Чтобы код было намного легче читать, используйте тесты для пустого/непустого
строки или пустые строки, а не символы-заполнители.

#+begin_example
# Do this:
if [[ "${my_var}" == "some_string" ]]; then
  do_something
fi

# -z (длина строки равна нулю) и -n (длина строки не равна нулю) равны
# предпочтительнее, чем тестирование пустой строки
if [[ -z "${my_var}" ]]; then
  do_something
fi

# Это нормально (убедитесь, что кавычки на пустой стороне), но не предпочтительно:
if [[ "${my_var}" == "" ]]; then
  do_something
fi
#+end_example

#+begin_example
# Не это:
if [[ "${my_var}X" == "some_stringX" ]]; then
  do_something
fi
#+end_example

Чтобы избежать путаницы в том, что вы тестируете, явно используйте =-z= или
=-n=.

#+begin_example
# Используйте это
if [[ -n "${my_var}" ]]; then
  do_something
fi
#+end_example

#+begin_example
# Вместо этого
if [[ "${my_var}" ]]; then
  do_something
fi
#+end_example

Для ясности используйте ==== для равенства, а не ===, хотя и то, и другое
работа. Первый поощряет использование =[[=, а второй может быть
перепутал с заданием. Однако будьте осторожны при использовании =<= и =>=
in =[[ ... ]] =, который выполняет лексикографическое сравнение. Используйте =( ... )) =
или =-lt= и =-gt= для численного сравнения.

#+begin_example
# Используйте это
if [[ "${my_var}" == "val" ]]; then
  do_something
fi

if (( my_var > 3 )); then
  do_something
fi

if [[ "${my_var}" -gt 3 ]]; then
  do_something
fi
#+end_example

#+begin_example
# Instead of this
if [[ "${my_var}" = "val" ]]; then
  do_something
fi

# Вероятно, непреднамеренное лексикографическое сравнение.
if [[ "${my_var}" > 3 ]]; then
  # True for 4, false for 22.
  do_something
fi
#+end_example

*** Расширение имен файлов с помощью подстановочных знаков
    :PROPERTIES:
    :CUSTOM_ID: s6.5-wildcard-expansion-of-filenames
    :END:
Используйте явный путь при расширении имен файлов с подстановочными знаками.

Поскольку имена файлов могут начинаться с =-=, гораздо безопаснее расширять подстановочные знаки
с =./*= вместо =*=.

#+begin_example
# Вот содержимое каталога:
# -f  -r  somedir  somefile

# Некорректно удаляет почти все в каталоге принудительно
psa@bilby$ rm -v *
removed directory: `somedir'
removed `somefile'
#+end_example

#+begin_example
# В отличие от:
psa@bilby$ rm -v ./*
removed `./-f'
removed `./-r'
rm: cannot remove `./somedir': Is a directory
removed `./somefile'
#+end_example

*** Eval
    :PROPERTIES:
    :CUSTOM_ID: s6.6-eval
    :END:
=eval= следует избегать.

Eval Преобразует входные данные при использовании для присвоения переменным и может устанавливать
без возможности проверить, что это были за переменные.

#+begin_example
# Что это устанавливает?
# Удалось ли это? Частично или целиком?
eval $(set_my_variables)

# Что произойдет, если в одном из возвращенных значений будет пробел?
variable="$(eval some_function)"
#+end_example

*** Массивы
    :PROPERTIES:
    :CUSTOM_ID: s6.7-arrays
    :END:
Массивы Bash следует использовать для хранения списков элементов, чтобы избежать кавычек
Осложнений. Особенно это относится к спискам аргументов. Массивы
не следует использовать для упрощения более сложных структур данных (см.
[[#s1.2-when-to-use-shell][Когда использовать оболочку]] выше).

Массивы хранят упорядоченную коллекцию строк и могут быть безопасно
развёрнут на отдельные элементы для команды или цикла.

Следует избегать использования одной строки для нескольких аргументов команды,
так как это неизбежно приводит к тому, что авторы используют =eval= или пытаются вложить кавычки
внутри строки, что не дает достоверных или читаемых результатов и
приводит к ненужной сложности.

#+begin_example
# Массив назначается с помощью круглых скобок и может быть добавлен к
# with +=( … ).
declare -a flags
flags=(--foo --bar='baz')
flags+=(--greeting="Hello ${name}")
mybinary "${flags[@]}"
#+end_example

#+begin_example
# Не используйте строки для последовательностей.
flags='--foo --bar=baz'
flags+=' --greeting="Hello world"'  # Это не будет работать должным образом.
mybinary ${flags}
#+end_example

#+begin_example
# Расширения команд возвращают отдельные строки, а не массивы. Избегать
# расширение без кавычек в назначениях массивов, потому что оно не будет
# работать корректно, если вывод команды содержит специальные
# символы или пробелы.

# Это разворачивает вывод листинга в строку, а затем делает специальное ключевое слово
# расширение, а затем разделение пробелов.  Только тогда он превращается в
# список слов.  Команда ls также может изменять поведение в зависимости от того, что пользователь
# активная среда!
declare -a files=($(ls /directory))

# get_arguments записывает все в STDOUT, но затем проходит через
# тот же процесс расширения, описанный выше, прежде чем превратиться в список аргументов.
mybinary $(get_arguments)
#+end_example

**** Массивы Плюсы:
     :PROPERTIES:
     :CUSTOM_ID: arrays-pros
     :END:
- Использование массивов позволяет составлять списки вещей без путаницы в кавычках.
  семантика. И наоборот, отказ от использования массивов приводит к ошибочным попыткам
  вложение в кавычки внутри строки.
- Массивы позволяют безопасно хранить последовательности/списки произвольных
  строки, включая строки, содержащие пробелы.

**** Массивы Минусы
     :PROPERTIES:
     :CUSTOM_ID: arrays-cons
     :END:
Использование массивов может привести к усложнению скрипта.

**** Решение по массивам
     :PROPERTIES:
     :CUSTOM_ID: arrays-decision
     :END:
Массивы следует использовать для безопасного создания списков и их передачи. В
В частности, при построении набора аргументов команды используйте массивы для
Избегайте путаницы с цитированием. Используйте расширение в кавычках -- ="${array[@]}"=
-- для доступа к массивам. Однако, если более продвинутая обработка данных
обязательно, следует вообще избегать сценариев оболочки; видеть
[[#s1.2-when-to-use-shell][выше]].

*** Перенаправление в цикл while
    :PROPERTIES:
    :CUSTOM_ID: s6.8-pipes-to-while
    :END:
Используйте подстановку процесса или =readarray= встроенный (bash4+) в
Предпочтение, а не конвейер =while=. Трубы создают подоболочку, поэтому любой
Переменные, измененные в конвейере, не распространяются на родительский объект
оболочка.

Неявная подоболочка в канале =while= может вносить тонкие ошибки
которые трудно отследить.

#+begin_example
last_line='NULL'
your_command | while read -r line; do
  if [[ -n "${line}" ]]; then
    last_line="${line}"
  fi
done

# Это всегда будет выводить 'NULL'!
echo "${last_line}"
#+end_example

При использовании подстановки процесса также создается подоболочка. Тем не менее, это позволяет
перенаправление из подоболочки в =while= без указания =while= (или
любая другая команда) в подоболочке.

#+begin_example
last_line='NULL'
while read line; do
  if [[ -n "${line}" ]]; then
    last_line="${line}"
  fi
done < <(your_command)

# Это выведет последнюю непустую строку из your_command
echo "${last_line}"
#+end_example

Кроме того, используйте встроенный =readarray= для чтения файла в файл
, а затем проведите цикл по содержимому массива. Обратите внимание, что (для того же
причина, как указано выше), вам нужно использовать подстановку процесса с =readarray=
а не труба, но с тем преимуществом, что генерация входных данных для
Петля располагается перед ним, а не после.

#+begin_example
last_line='NULL'
readarray -t lines < <(your_command)
for line in "${lines[@]}"; do
  if [[ -n "${line}" ]]; then
    last_line="${line}"
  fi
done
echo "${last_line}"
#+end_example

#+begin_quote
  Примечание: Будьте осторожны, используя цикл for, чтобы перебирать выходные данные, как в
  =для var в $(...) =, так как выходные данные разделены пробелами, а не пробелами
  линия. Иногда вы будете знать, что это безопасно, потому что вывод не может
  содержат любые неожиданные пробелы, но если это не очевидно или
  не улучшает читаемость (например, длинная команда внутри =$(...) =),
  Цикл =while read= или =readarray= часто безопаснее и понятнее.
#+end_quote

*** Арифметика
    :PROPERTIES:
    :CUSTOM_ID: s6.9-arithmetic
    :END:
Всегда используйте =(( ... )) = или =$( ... )) =, а не =let= или =$[ ... ] = или
=expr=.

Никогда не используйте =$[ ... ] =, команда =expr= или =let=
встроенный.

=<= и =>= не выполняют числовое сравнение внутри =[[ ... ]] =
выражения (вместо этого они выполняют лексикографические сравнения; см.
[[#s6.4-testing-strings][Testing Strings]]). Для предпочтения не используйте
=[[ ... ]] = /вообще/ для числовых сравнений используйте =(( ... )) = вместо.

Рекомендуется избегать использования =(( ... )) = как отдельное утверждение,
и в противном случае будьте осторожны с его выражением, оценивающим до нуля -
В частности, с включенным =set -e=. Например
=set -e; i=0; (( i++ ))= приведет к выходу из оболочки.

#+begin_example
# Простое вычисление, используемое в виде текста - обратите внимание на использование $( ... )) в пределах
# строка.
echo "$(( 2 + 2 )) is 4"

# При выполнении арифметических сравнений для тестирования
if (( a < b )); then
  …
fi

# Некоторые вычисления, назначенные переменной.
(( i = 10 * j + 400 ))
#+end_example

#+begin_example
# Эта форма не является переносимой и устарела
i=$[2 * 10]

# Несмотря на внешний вид, «let» не является одним из декларативных ключевых слов,
# Таким образом, некавычные задания подлежат разделению слов.
# Для простоты избегайте «let» и используйте (( ... ))
let i="2 + 2"

# Утилита expr является внешней программой, а не встроенной оболочкой.
i=$( expr 4 + 4 )

# Цитирование также может быть подвержено ошибкам при использовании expr.
i=$( expr 4 '*' 4 )
#+end_example

Если оставить в стороне стилистические соображения, встроенной арифметики оболочки много
в разы быстрее, чем =expr=.

При использовании переменных формы =${var}= (и =$var=) не являются обязательными
в пределах =$(( ... )) =. Оболочка знает, что нужно искать =var= для вас, и
Опуская =${...} = приводит к более чистому коду. Это немного противоречит
Предыдущее правило о том, чтобы всегда использовать брекеты, так что это рекомендация
только.

#+begin_example
# N.B.: Не забудьте объявить переменные целыми числами, когда
# возможно, и предпочесть локальные переменные глобальным.
local -i hundred=$(( 10 * 10 ))
declare -i five=$(( 10 / 2 ))

# Увеличьте переменную "i" на три.
# Обратите внимание, что:
#  - We do not write ${i} or $i.
#  - We put a space after the (( and before the )).
(( i += 3 ))

# Чтобы уменьшить переменную "i" на пять:
(( i -= 5 ))

# Выполните некоторые сложные вычисления.
# Обратите внимание, что соблюдается нормальный арифметический приоритет операторов.
hr=2
min=5
sec=30
echo $(( hr * 3600 + min * 60 + sec )) # печатает 7530, как и ожидалось
#+end_example

** Соглашения об именовании
   :PROPERTIES:
   :CUSTOM_ID: s7-naming-conventions
   :END:

*** Имена функций
    :PROPERTIES:
    :CUSTOM_ID: s7.1-function-names
    :END:
Строчные буквы, с подчеркиваниями для разделения слов. Отдельные библиотеки с
=::=. Круглые скобки обязательны после имени функции. Ключевое слово
=function= является необязательным, но должен использоваться последовательно на протяжении всего
проект.

Если вы пишете отдельные функции, используйте строчные и отдельные слова
с подчеркиванием. Если вы пишете пакет, разделите имена пакетов
с =::=. Фигурные скобки должны находиться в той же строке, что и имя функции (например,
другие языки в Google) и отсутствие пробела между именем функции и
Круглые скобки.

#+begin_example
# Одиночная функция
my_func() {
  …
}

# Часть пакета
mypackage::my_func() {
  …
}
#+end_example

Ключевое слово =function= является посторонним, если после символа присутствует символ "()"
имя функции, но улучшает быструю идентификацию функций.

*** Имена переменных
    :PROPERTIES:
    :CUSTOM_ID: s7.2-name-variable
    :END:
Что касается имен функций.

Имена переменных для циклов должны быть одинаковыми для любой переменной
Вы зацикливаетесь.

#+begin_example
for zone in "${zones[@]}"; do
  something_with "${zone}"
done
#+end_example

*** Имена констант и переменных среды
    :PROPERTIES:
    :CUSTOM_ID: s7.3-constants-and-environment-variable-names
    :END:
Все заглавные буквы, разделенные символами подчеркивания, объявлены в верхней части файла.

Константы и все, что экспортируется в среду, должно быть
Капитализированы.

#+begin_example
# Постоянный
readonly PATH_TO_FILES='/some/path'

# Как постоянная, так и окружающая среда
declare -xr ORACLE_SID='PROD'
#+end_example

Некоторые вещи становятся постоянными при первой настройке (например, через
getopts). Таким образом, можно установить константу в getopts или на основе
условие, но сразу после этого его следует сделать доступным только для чтения. Для
Для ясности рекомендуется =readonly= или =export= вместо параметра
эквивалентные команды =declare=.

#+begin_example
VERBOSE='false'
while getopts 'v' flag; do
  case "${flag}" in
    v) VERBOSE='true' ;;
  esac
done
readonly VERBOSE
#+end_example

*** Имена исходных файлов
    :PROPERTIES:
    :CUSTOM_ID: s7.4-source-filenames
    :END:
Строчные буквы, с подчеркиваниями для разделения слов, если это необходимо.

Это сделано для согласованности с другими стилями кода в Google: =maketemplate=
или =make_template=, но не =make-template=.

*** Переменные, доступные только для чтения
    :PROPERTIES:
    :CUSTOM_ID: s7.5-read-only-variables
    :END:
Используйте =readonly= или =declare -r=, чтобы убедиться, что они доступны только для чтения.

Поскольку глобалы широко используются в оболочке, важно выявлять ошибки, когда
Работа с ними. Когда вы объявляете переменную, которая должна быть
только для чтения, сделайте это явным.

#+begin_example
zip_version="$(dpkg --status zip | grep Version: | cut -d ' ' -f 2)"
if [[ -z "${zip_version}" ]]; then
  error_message
else
  readonly zip_version
fi
#+end_example

*** Использование локальных переменных
    :PROPERTIES:
    :CUSTOM_ID: s7.6-use-local-variables
    :END:
Объявите переменные, зависящие от функции, с помощью =local=. Декларация и
Назначение должно быть на разных строках.

Убедитесь, что локальные переменные видны только внутри функции и ее
дочерние элементы, используя =local= при их объявлении. Это позволяет избежать загрязнения
глобальное пространство имен и непреднамеренная установка переменных, которые могут иметь
значимость вне функции.

Декларация и уступка должны быть отдельными заявлениями, когда
значение присваивания обеспечивается подстановкой команды; как =local=
builtin не распространяет код выхода из команды подстановки.

#+begin_example
my_func2() {
  local name="$1"

  # Отдельные строки для декларирования и присвоения:
  local my_var
  my_var="$(my_func)"
  (( $? == 0 )) || return

  …
}
#+end_example

#+begin_example
my_func2() {
  # НЕ делайте этого:
  # $? всегда будет равен нулю, так как содержит код выхода 'local', а не my_func
  local my_var="$(my_func)"
  (( $? == 0 )) || return

  …
}
#+end_example

*** Расположение функции
    :PROPERTIES:
    :CUSTOM_ID: s7.7-function-location
    :END:
Соберите все функции вместе в файле чуть ниже констант. Не прячьтесь
исполняемый код между функциями. Это затрудняет выполнение кода
Следуйте и приводит к неприятным сюрпризам при отладке.

Если у вас есть функции, соедините их все вместе в верхней части файла.
Только включает, =set= операторы и настройки констант могут быть выполнены ранее
объявление функций.

*** главный
    :PROPERTIES:
    :CUSTOM_ID: s7.8-main
    :END:
Функция =main= требуется для скриптов, достаточно длинных, чтобы содержать:
по крайней мере, еще одна функция.

Для того, чтобы легко найти старт программы, поставьте основную программу
в функции =main= как самая нижняя функция. Это обеспечивает:
согласованность с остальной кодовой базой, а также возможность
Определите больше переменных как =local= (что невозможно сделать, если основной код
не является функцией). Последняя строка без комментариев в файле должна быть
вызов =main=:

#+begin_example
main "$@"
#+end_example

Очевидно, что для коротких скриптов, где это просто линейный поток, =main= равно
Перебор и так не требуется.

** Вызов команд
   :PROPERTIES:
   :CUSTOM_ID: s8-calling-commands
   :END:

*** Проверка возвращаемых значений
    :PROPERTIES:
    :CUSTOM_ID: s8.1-checking-return-values
    :END:
Всегда проверяйте возвращаемые значения и предоставляйте информативные возвращаемые значения.

Для команд без конвейера используйте =$?= или проверьте напрямую с помощью оператора =if=
чтобы все было просто.

Пример:

#+begin_example
if ! mv "${file_list[@]}" "${dest_dir}/"; then
  echo "Unable to move ${file_list[*]} to ${dest_dir}" >&2
  exit 1
fi

# Или
mv "${file_list[@]}" "${dest_dir}/"
if (( $? != 0 )); then
  echo "Unable to move ${file_list[*]} to ${dest_dir}" >&2
  exit 1
fi
#+end_example

Bash также имеет переменную =PIPESTATUS=, которая позволяет проверить
Возвращайте код из всех частей трубы. Если нужно только проверить
Успех или неудача всей трубы, то допустимо следующее:

#+begin_example
tar -cf - ./* | ( cd "${dir}" && tar -xf - )
if (( PIPESTATUS[0] != 0 || PIPESTATUS[1] != 0 )); then
  echo "Unable to tar files to ${dir}" >&2
fi
#+end_example

Однако, поскольку =PIPESTATUS= будет перезаписан, как только вы сделаете любое другое
, если вам нужно действовать по-разному на ошибках в зависимости от того, где она
произошло в канале, вам нужно будет назначить =PIPESTATUS= другому
сразу после выполнения команды (не забывайте, что =[= is
и сотрет =PIPESTATUS=).

#+begin_example
tar -cf - ./* | ( cd "${DIR}" && tar -xf - )
return_codes=( "${PIPESTATUS[@]}" )
if (( return_codes[0] != 0 )); then
  do_something
fi
if (( return_codes[1] != 0 )); then
  do_something_else
fi
#+end_example

*** Встроенные команды и внешние команды
    :PROPERTIES:
    :CUSTOM_ID: s8.2-builtin-commands-vs.-external-commands
    :END:
Выбор между вызовом встроенной оболочки и вызовом
Отделите процесс, выберите встроенный.

Мы предпочитаем использовать встроенные функции, такие как /Parameter Expansion/
функционирует в =bash(1)=, так как он более надежен и переносим (особенно когда
по сравнению с такими вещами, как =sed=).

Примеры:

#+begin_example
# Prefer this:
addition=$(( X + Y ))
substitution="${string/#foo/bar}"
#+end_example

#+begin_example
# Instead of this:
addition="$(expr "${X}" + "${Y}")"
substitution="$(echo "${string}" | sed -e 's/^foo/bar/')"
#+end_example

** Заключение
   :PROPERTIES:
   :CUSTOM_ID: s9-conclusion
   :END:
Руководствуйтесь здравым смыслом и /БУДЬТЕ ПОСЛЕДОВАТЕЛЬНЫ/.

Пожалуйста, уделите несколько минут, чтобы прочитать раздел «Напутствие» на сайте

[[https://google.github.io/styleguide/cppguide.html#Parting_Words][C++ Guide]].

Пересмотр 2.02

